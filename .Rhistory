install.packages("gifski")
install.packages("av")
library(gganimate)
p + transition_time(date) +
labs(title = "Date: {frame_time}")
install.packages("transformr")
p + transition_time(date) +
labs(title = "Date: {frame_time}")
library(osmdata)
library(tidyverse)
library(sf)
library(lwgeom) #for the water area calculation
library(gganimate)
bins <- read_csv("data/aggregated_bin_data.csv")
place <- "Edinburgh UK"
#set thickness depends on type of line
highway_sizes <- tibble::tribble(
~highway, ~highway_group, ~size,
"motorway",        "large",   0.5,
"motorway_link",        "large",   0.3,
"primary",        "large",   0.5,
"primary_link",        "large",   0.3,
"secondary",       "medium",   0.3,
"secondary_link",       "medium",   0.3,
"tertiary",       "medium",   0.3,
"tertiary_link",       "medium",   0.3,
"residential",        "small",   0.2,
"living_street",        "small",   0.2,
"unclassified",        "small",   0.2,
"service",        "small",   0.2,
"footway",        "small",   0.2,
"pedestrian", "small", 0.2
)
# get streets
streets_osm <- opq(place) %>% #Build an Overpass query
add_osm_feature(key = "highway",
value = highway_sizes$highway) %>%
osmdata_sf()
#get names of Edinburgh streets
unique(streets_osm$osm_lines$name)
#added name.left as there was some small streets which are subparts of other streets (investigated missing streets without this term in https://www.openstreetmap.org/way/183699651)
streets <- streets_osm$osm_lines %>%
dplyr::select(osm_id, name, highway, maxspeed, oneway, surface, name.left) %>%
mutate(length = as.numeric(st_length(.))) %>%
left_join(highway_sizes, by="highway")
# get railways
railways_osm <- opq(place) %>%
add_osm_feature(key = "railway", value="rail") %>%
osmdata_sf()
railways <- railways_osm$osm_lines %>%
dplyr::select()
# get rivers
river_osm <- opq(place) %>%
add_osm_feature(key = "waterway", value = c("river", "riverbank")) %>%
osmdata_sf() %>%
unname_osmdata_sf()
# get water - extra since polygon
water_osm <- opq(place) %>%
add_osm_feature(key = "natural", value = "water") %>%
osmdata_sf() %>%
unname_osmdata_sf()
water <- c(water_osm, river_osm) %>%
.$osm_multipolygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.)) %>% #uses lwgeom library
filter(area >= quantile(area, probs = 0.75))   # this filter gets rid of tiny isolated lakes
#got key/value pairs from https://wiki.openstreetmap.org/wiki/Map_features
green_osm <- opq(place) %>%
add_osm_feature(key = "landuse", value = c("recreation_ground", "village_green", "grass", "greenfield", "meadow", "forest")) %>%
osmdata_sf() %>%
unname_osmdata_sf()
green <- c(green_osm) %>%
.$osm_polygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.))  #uses lwgeom library
park_osm <- opq(place) %>%
add_osm_feature(key = "leisure", value = c("park")) %>%
osmdata_sf() %>%
unname_osmdata_sf()
park_poly <- c(park_osm) %>%
.$osm_polygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.))  #uses lwgeom library
park_multipoly <- c(park_osm) %>%
.$osm_multipolygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.))
park <- bind_rows(park_poly, park_multipoly)
# Box ---------------------------------------------------------------------
# decide cut off for centre of Edinburgh
bbox <- c(ymin= 55.928479867725436,
xmin= -3.227624857214751,
ymax= 55.98333902701634,
xmax= -3.140735628435386)
# Crop all the roads/water/rail to boundary set
water_cropped <- st_crop(water, bbox)
streets_cropped <- st_crop(streets, bbox)
railways_cropped <- st_crop(railways, bbox)
green_cropped <- st_crop(green, bbox)
park_poly_cropped <- st_crop(park_poly, bbox)
#there are repeats of some roads because can be broken up/classified as different categories ('highway' variable)
# take the longest length values of each
streets_cropped <- streets_cropped %>%
group_by(name, name.left) %>%
mutate(max_length = max(length)) %>%
filter(length == max_length)
# Bin data ----------------------------------------------------------------
# EDA on bin data streest
bin_streets <- bins %>%
select(street_name) %>%
distinct()
bin_streets %>% count()
map_streets <- as_tibble(streets_cropped$name) %>%
mutate(value = str_to_lower(value)) %>%
distinct()
map_streets %>% count()
#no matches for 23 streets
no_match <- bin_streets %>% anti_join(map_streets, by = c("street_name" = "value"))
no_match
#from inspection these look to be small streets so may not be named in the osmdata
map_streets_nameleft <- as_tibble(streets_cropped$name.left) %>%
mutate(value = str_to_lower(value)) %>%
distinct()
no_match %>% anti_join(map_streets_nameleft, by = c("street_name" = "value"))
# notes from manual inspection:
# promanade & st mark's place is in portebello - outside area looking to concentrate on
# gayfield square park, leith links, princes street gardens east, princes street gardens west are all parks so decide to omit do to visualising 'amount' of data via thickness of line of street which would not be approrpiate for park polygon space
# restalrig railway path is a cycleway on OSM so choose to omit.
streets_cropped <- streets_cropped %>%
mutate(name = str_to_lower(name)) %>%
mutate(name.left = str_to_lower(name.left)) %>%
rename(sub_street_name = name.left)
bins <- bins %>%
mutate(street_name = case_when(
street_name == "atholl cresent" ~ "atholl crescent", #spelling error in bin data
TRUE ~ street_name)) %>%
filter(str_detect(street_name, "square", negate = TRUE)) #remove any 'squares' as does not visualise well for this
last_date_bin_collection <- bins %>%
group_by(street_name) %>%
arrange(street_name, desc(date)) %>%
slice_max(1)
# first check to join by 'street_name' column
last_date_bin_collection_first_join <- last_date_bin_collection %>%
inner_join(streets_cropped, by = c("street_name" = "name"))
# for any ones which don't match on 'street_name' try on 'sub_street_name' as this has info on smaller sub streets
last_date_bin_collection_second_join <- last_date_bin_collection %>%
anti_join(streets_cropped, by = c("street_name" = "name")) %>%
inner_join(streets_cropped, by = c("street_name" = "sub_street_name")) %>%
select(-name)
# combine data from first and second join checks
last_date_bin_collection_sf <- bind_rows(last_date_bin_collection_first_join, last_date_bin_collection_second_join) %>%
st_as_sf() #convert to sf object
# Plotting ----------------------------------------------------------------
blankbg <-theme(axis.line=element_blank(),
axis.text.x=element_blank(),
axis.text.y=element_blank(),
axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
# legend.position = "none",
plot.background=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
panel.grid.major=element_blank(),
plot.margin = unit(c(t=2,r=2,b=2,l=2), "cm"),
plot.caption = element_text(color = "grey20", size = 12,
hjust = .5, face = "plain",
family = "Didot"),
panel.border = element_blank()
)
# potential to change over time https://www.datanovia.com/en/blog/gganimate-how-to-create-plots-with-beautiful-animation-in-r/
full_bin_data_first_join <- bins %>%
inner_join(streets_cropped, by = c("street_name" = "name"))
# for any ones which don't match on 'street_name' try on 'sub_street_name' as this has info on smaller sub streets
full_bin_data_second_join <- bins %>%
anti_join(streets_cropped, by = c("street_name" = "name")) %>%
inner_join(streets_cropped, by = c("street_name" = "sub_street_name")) %>%
select(-name)
# combine data from first and second join checks
full_bin_data_sf <- bind_rows(full_bin_data_first_join, full_bin_data_second_join) %>%
st_as_sf() #convert to sf object
p <- ggplot() +
blankbg +
geom_sf(data = water_cropped,
fill = "steelblue",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = park_multipoly,
fill = "green",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = park_poly_cropped,
fill = "green",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = railways_cropped,
color = "grey30",
size = .2,
linetype="dotdash",
alpha = .5) +
geom_sf(data = streets_cropped %>%
filter(highway_group == "small"),
size = .1,
color = "grey40") +
geom_sf(data = streets_cropped %>%
filter(highway_group == "medium"),
size = .3,
color = "grey35") +
geom_sf(data = streets_cropped %>%
filter(highway_group == "large"),
size = .5,
color = "grey30") +
geom_sf(data =  full_bin_data_sf, aes(size = cum_total), color = "red", show.legend = "line") +
labs(caption = 'Edinburgh - bin sensor project', size = 2) +
coord_sf(ylim = c(bbox[1], bbox[3]),
xlim = c(bbox[2], bbox[4]),
expand = FALSE)
p + transition_time(date) +
labs(title = "Date: {frame_time}")
full_bin_data_sf
full_bin_data_sf %>%
arrange(street_name, sub_street_name, date)
full_bin_data_sf %>%
arrange(street_name, sub_street_name, date) %>%
mutate(joining_street = coalesce(street_name, sub_street_name))
full_bin_data_sf %>%
arrange(street_name, sub_street_name, date) %>%
mutate(joining_street = coalesce(street_name, sub_street_name)) %>%
complete(joining_street, nesting(date))
# first check to join by 'street_name' column
full_bin_data_first_join <- bins %>%
inner_join(streets_cropped, by = c("street_name" = "name"))
# for any ones which don't match on 'street_name' try on 'sub_street_name' as this has info on smaller sub streets
full_bin_data_second_join <- bins %>%
anti_join(streets_cropped, by = c("street_name" = "name")) %>%
inner_join(streets_cropped, by = c("street_name" = "sub_street_name")) %>%
select(-name)
# combine data from first and second join checks
full_bin_data_sf <- bind_rows(full_bin_data_first_join, full_bin_data_second_join) %>%
st_as_sf() #convert to sf object
#there isn't a row at every date for every street
full_bin_data_sf %>%
arrange(street_name, sub_street_name, date) %>%
mutate(joining_street = coalesce(street_name, sub_street_name)) %>%
complete(joining_street, nesting(date))
# TO FINISH - complete cumulative amounts
p <- ggplot() +
blankbg +
geom_sf(data = water_cropped,
fill = "steelblue",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = park_multipoly,
fill = "green",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = park_poly_cropped,
fill = "green",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = railways_cropped,
color = "grey30",
size = .2,
linetype="dotdash",
alpha = .5) +
geom_sf(data = streets_cropped %>%
filter(highway_group == "small"),
size = .1,
color = "grey40") +
geom_sf(data = streets_cropped %>%
filter(highway_group == "medium"),
size = .3,
color = "grey35") +
geom_sf(data = streets_cropped %>%
filter(highway_group == "large"),
size = .5,
color = "grey30") +
geom_sf(data =  full_bin_data_sf, aes(size = cum_total), color = "red", show.legend = "line") +
labs(caption = 'Edinburgh - bin sensor project', size = 2) +
coord_sf(ylim = c(bbox[1], bbox[3]),
xlim = c(bbox[2], bbox[4]),
expand = FALSE)
p + transition_time(date) +
labs(title = "Date: {frame_time}")
library(osmdata)
library(tidyverse)
library(sf)
library(lwgeom) #for the water area calculation
library(gganimate)
# loading in bin data
bins <- read_csv("data/aggregated_bin_data.csv")
place <- "Edinburgh UK"
#set thickness depends on type of line
highway_sizes <- tibble::tribble(
~highway, ~highway_group, ~size,
"motorway",        "large",   0.5,
"motorway_link",        "large",   0.3,
"primary",        "large",   0.5,
"primary_link",        "large",   0.3,
"secondary",       "medium",   0.3,
"secondary_link",       "medium",   0.3,
"tertiary",       "medium",   0.3,
"tertiary_link",       "medium",   0.3,
"residential",        "small",   0.2,
"living_street",        "small",   0.2,
"unclassified",        "small",   0.2,
"service",        "small",   0.2,
"footway",        "small",   0.2,
"pedestrian", "small", 0.2
)
# get streets
streets_osm <- opq(place) %>% #Build an Overpass query
add_osm_feature(key = "highway",
value = highway_sizes$highway) %>%
osmdata_sf()
#get names of Edinburgh streets
unique(streets_osm$osm_lines$name)
#added name.left as there was some small streets which are subparts of other streets (investigated missing streets without this term in https://www.openstreetmap.org/way/183699651)
streets <- streets_osm$osm_lines %>%
dplyr::select(osm_id, name, highway, maxspeed, oneway, surface, name.left) %>%
mutate(length = as.numeric(st_length(.))) %>%
left_join(highway_sizes, by="highway")
# get railways
railways_osm <- opq(place) %>%
add_osm_feature(key = "railway", value="rail") %>%
osmdata_sf()
railways <- railways_osm$osm_lines %>%
dplyr::select()
# get rivers
river_osm <- opq(place) %>%
add_osm_feature(key = "waterway", value = c("river", "riverbank")) %>%
osmdata_sf() %>%
unname_osmdata_sf()
# get water - extra since polygon
water_osm <- opq(place) %>%
add_osm_feature(key = "natural", value = "water") %>%
osmdata_sf() %>%
unname_osmdata_sf()
water <- c(water_osm, river_osm) %>%
.$osm_multipolygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.)) %>% #uses lwgeom library
filter(area >= quantile(area, probs = 0.75))   # this filter gets rid of tiny isolated lakes
#got key/value pairs from https://wiki.openstreetmap.org/wiki/Map_features
green_osm <- opq(place) %>%
add_osm_feature(key = "landuse", value = c("recreation_ground", "village_green", "grass", "greenfield", "meadow", "forest")) %>%
osmdata_sf() %>%
unname_osmdata_sf()
green <- c(green_osm) %>%
.$osm_polygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.))  #uses lwgeom library
park_osm <- opq(place) %>%
add_osm_feature(key = "leisure", value = c("park")) %>%
osmdata_sf() %>%
unname_osmdata_sf()
park_poly <- c(park_osm) %>%
.$osm_polygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.))  #uses lwgeom library
park_multipoly <- c(park_osm) %>%
.$osm_multipolygons %>%
select(osm_id, name) %>%
mutate(area = st_area(.))
park <- bind_rows(park_poly, park_multipoly)
# Box ---------------------------------------------------------------------
# decide cut off for centre of Edinburgh
bbox <- c(ymin= 55.928479867725436,
xmin= -3.227624857214751,
ymax= 55.98333902701634,
xmax= -3.140735628435386)
# Crop all the roads/water/rail to boundary set
water_cropped <- st_crop(water, bbox)
streets_cropped <- st_crop(streets, bbox)
railways_cropped <- st_crop(railways, bbox)
green_cropped <- st_crop(green, bbox)
park_poly_cropped <- st_crop(park_poly, bbox)
#there are repeats of some roads because can be broken up/classified as different categories ('highway' variable)
# take the longest length values of each
streets_cropped <- streets_cropped %>%
group_by(name, name.left) %>%
mutate(max_length = max(length)) %>%
filter(length == max_length)
# Bin data ----------------------------------------------------------------
# EDA on bin data streest
bin_streets <- bins %>%
select(street_name) %>%
distinct()
bin_streets %>% count()
map_streets <- as_tibble(streets_cropped$name) %>%
mutate(value = str_to_lower(value)) %>%
distinct()
map_streets %>% count()
#no matches for 23 streets
no_match <- bin_streets %>% anti_join(map_streets, by = c("street_name" = "value"))
no_match
#from inspection these look to be small streets so may not be named in the osmdata
map_streets_nameleft <- as_tibble(streets_cropped$name.left) %>%
mutate(value = str_to_lower(value)) %>%
distinct()
no_match %>% anti_join(map_streets_nameleft, by = c("street_name" = "value"))
# notes from manual inspection:
# promanade & st mark's place is in portebello - outside area looking to concentrate on
# gayfield square park, leith links, princes street gardens east, princes street gardens west are all parks so decide to omit do to visualising 'amount' of data via thickness of line of street which would not be approrpiate for park polygon space
# restalrig railway path is a cycleway on OSM so choose to omit.
streets_cropped <- streets_cropped %>%
mutate(name = str_to_lower(name)) %>%
mutate(name.left = str_to_lower(name.left)) %>%
rename(sub_street_name = name.left)
bins <- bins %>%
mutate(street_name = case_when(
street_name == "atholl cresent" ~ "atholl crescent", #spelling error in bin data
TRUE ~ street_name)) %>%
filter(str_detect(street_name, "square", negate = TRUE)) #remove any 'squares' as does not visualise well for this
last_date_bin_collection <- bins %>%
group_by(street_name) %>%
arrange(street_name, desc(date)) %>%
slice_max(1)
# first check to join by 'street_name' column
last_date_bin_collection_first_join <- last_date_bin_collection %>%
inner_join(streets_cropped, by = c("street_name" = "name"))
# for any ones which don't match on 'street_name' try on 'sub_street_name' as this has info on smaller sub streets
last_date_bin_collection_second_join <- last_date_bin_collection %>%
anti_join(streets_cropped, by = c("street_name" = "name")) %>%
inner_join(streets_cropped, by = c("street_name" = "sub_street_name")) %>%
select(-name)
# combine data from first and second join checks
last_date_bin_collection_sf <- bind_rows(last_date_bin_collection_first_join, last_date_bin_collection_second_join) %>%
st_as_sf() #convert to sf object
# Plotting ----------------------------------------------------------------
blankbg <-theme(axis.line=element_blank(),
axis.text.x=element_blank(),
axis.text.y=element_blank(),
axis.ticks=element_blank(),
axis.title.x=element_blank(),
axis.title.y=element_blank(),
# legend.position = "none",
plot.background=element_blank(),
panel.grid.minor=element_blank(),
panel.background=element_blank(),
panel.grid.major=element_blank(),
plot.margin = unit(c(t=2,r=2,b=2,l=2), "cm"),
plot.caption = element_text(color = "grey20", size = 12,
hjust = .5, face = "plain",
family = "Didot"),
panel.border = element_blank()
)
# potential to change over time https://www.datanovia.com/en/blog/gganimate-how-to-create-plots-with-beautiful-animation-in-r/
# first check to join by 'street_name' column
full_bin_data_first_join <- bins %>%
inner_join(streets_cropped, by = c("street_name" = "name"))
# for any ones which don't match on 'street_name' try on 'sub_street_name' as this has info on smaller sub streets
full_bin_data_second_join <- bins %>%
anti_join(streets_cropped, by = c("street_name" = "name")) %>%
inner_join(streets_cropped, by = c("street_name" = "sub_street_name")) %>%
select(-name)
# combine data from first and second join checks
full_bin_data_sf <- bind_rows(full_bin_data_first_join, full_bin_data_second_join) %>%
st_as_sf() #convert to sf object
#there isn't a row at every date for every street
full_bin_data_sf %>%
arrange(street_name, sub_street_name, date) %>%
mutate(joining_street = coalesce(street_name, sub_street_name)) %>%
complete(joining_street, nesting(date))
# TO FINISH - complete cumulative amounts
p <- ggplot() +
blankbg +
geom_sf(data = water_cropped,
fill = "steelblue",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = park_multipoly,
fill = "green",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = park_poly_cropped,
fill = "green",
# size = .8,
lwd = 0,
alpha = .3) +
geom_sf(data = railways_cropped,
color = "grey30",
size = .2,
linetype="dotdash",
alpha = .5) +
geom_sf(data = streets_cropped %>%
filter(highway_group == "small"),
size = .1,
color = "grey40") +
geom_sf(data = streets_cropped %>%
filter(highway_group == "medium"),
size = .3,
color = "grey35") +
geom_sf(data = streets_cropped %>%
filter(highway_group == "large"),
size = .5,
color = "grey30") +
geom_sf(data =  full_bin_data_sf, aes(size = cum_total), color = "red", show.legend = "line") +
labs(caption = 'Edinburgh - bin sensor project', size = 2) +
coord_sf(ylim = c(bbox[1], bbox[3]),
xlim = c(bbox[2], bbox[4]),
expand = FALSE)
p + transition_time(date) +
labs(title = "Date: {frame_time}")
